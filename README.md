# Проект образец проекта бота

## Как начать писать проект

Прежде чем начать писать хоть какой-то код (а уж тем более в команде), необходимо определиться с темой и
функционалом для проекта, накидать функционал, структрировать эту информацию и идти делать.

Раз уж это воркшоп в рамках хакатона, то давайте в качестве темы возьмём что-то связное.

Предположим мы хотим сделать сервис по матчингу команды на хакатон. Эта идея нашего проекта. Теперь нам нужно
эту идею развить и формализовать, иначе как в басне, все участники проекта представят в голове своё видение и результат
никого не устроит.

### Суть проекта

Бот, для помощи одиноким участникам. Они могут зарегистрироваться в боте, указать свои анкетные данные (роль, возможно
возраст и интересуемые темы) и получать предложения по вступлению в команду или же отправить своё приглашение ранее
зарегистрированным командам.

> На этапе описания сути проекта лучшим вариантом будет набрасывать все возможные идеи (делает это вся команда проекта
> вместе),
> чтобы потом выбрать из них лучше и не противоречащие друг другу. Ещё такой этап называют мозговым штурмом.

И так, какие люди будут приходить в бота:

- люди вообще без команды и особых навыков, которые просто хотят поучаствовать
- одинокие специалисты (дизайнеры, разработчики), которые уже знают как грести
- недоукомплектованные команды

Т.к. аудитория разная, нужно заложить возможность автоматической группировки команд. Чтобы это сделать, фиксируем, что у
команды будет:

- лидер (любой из участников, возможно первый. Хорошо бы было дать возможность лидера менять, а ещё лучше назначать
  после укомплектовки)
- разработчик (backend и frontend. Тут мы упускаем варианты сбора команд на ботов, где бэк не нужен. Но мы дадим
  возможность командам "решать что они укомплектованы" самостоятельно, так что они могут просто не дожидаться других
  ролей)
- дизайнер (опционально), чтобы помогать делать красиво и продумывать интерфейс до его реализации
- "на подхвате" - люди без особых навыков, которые просто хотят поучаствовать
- _цель_ - берётся от первого участника в команде, а потом меняется. Без неё новоприбывающим будет сложно определиться с
  тем, какую команду выбрать.

Также, по возможности, стоило бы не давать возможность людям общаться напрямую, а то они не будут пользоваться нашим
ботом (но это мы возможно откинем, т.к. время на разработку не бесконечное).

### Функционал

Исходя из накиданного выше, мы имеем следующий функционал:

- регистрация
- заполнение профиля о себе
- поиск/создание команды
- общение с другими потенциальными участниками
- укомплектовка команды + назначение лидера команды
- отображение списка свободных участников и неукомплектованных команд
- уведомление о новых участниках/командах

### Event Storming

На этапах выше мы уже получили какой-то контекст и понимание того, что будет представлять из себя бот. НО, мы не
задумывались о том, как это будет реализовываться, какие сущности у нас будут храниться в БД и как мы будем с ними
взаимодействовать. Хорошим вариантом для этого является Event Storming. в целом, он может проводиться во время мозгового
штурма, а может делаться уже и после. Тут всё зависит от команды, которая реализует проект.

Вот для примера, event storming, который я делал в рамках своего
обучения https://drive.google.com/file/d/1m3sP2oJGHs9ZgsTWfn-XTfSfru0Bgh-5/view (там всё тоже не совсем правильно, но
уже что-то)

Ну а тут мы попробуем составить новый, под задачу.

Рекомендую глянуть диаграмму по ссылке выше, т.к. там указаны определения (можно всё и в гугле вычитать, но я постараюсь
максимально кратко отразить суть).

Ключевое, вокруг чего строится такой подход проектирования - Событие (Event). Мы думаем какие события у нас есть в
системе и накидываем их на доску. Как только мы определились с событиями, мы определяем какая Команда (или действие, оно
же Command), будет причиной этого события. Ну а совершает действие Актор. Также у события может быть (а может и не быть)
модель чтения (данные, которые мы будем показывать или передавать по этому действию).

Последовательность простая:

1. накидайте событий (проще всего начать с обозначенного функционала)
2. сгруппируйте их исходя из Агрегата (сущности/табличики БД, вокруг которых они будут крутиться)
3. распишите каждое действие (добавьте актора, команду и модель чтения, если таковая нужна)
4. приступайте к работе ! (на каждую кучку команд можно назначить отдельного человека, который будет за неё отвечать)

Логика такого действия, что сгруппированные кучки будут сильно связаны (т.к. работают с одними и теми же данными) и если
давать делать одну кучку разным людям, они будут сильно друг другу мешать. А вот дописать логику взаимодействия между
кучками можно и позже, после накидывания основного функционала.

-----

А получилось в итоге https://miro.com/app/board/uXjVNNHKoOY=/?share_link_id=166167073356

По идее, после такого проектирования, можно начать выделять домены, агрегаты и расписывать части системы подробнее. Но у
нас довольно маленький проект и мы это попросту опустим.

-----

## Разработка

### Быстрый старт

1. Устанавливаем python 3.10
2. Создаём виртуальное окружение для проекта (через IDE или через `python -m venv ./venv` в корне проекта)
3. Активируем окружение в консоли (выполняем `./venv/bin/activate` или `activate.ps1` для windows)
4. Устанавливаем зависимости через `python -m pip install -r ./requirements.txt`
5. Создаём файл .env (в корневой папке проекта) по образцу из .env.example (это только пример заполнения, полный список
   переменных можно найти в `bot/core/config::Config`)
6. Добавляем директорию `/bot` в `PYTHONPATH` переменную среды (чтобы все импорты не содержали `bot.`)
    - при запуске через консоль ничего делать не нужно `python bot/main.py` уже будет работать
    - при запуске через pycharm необходимо ткнуть на директорию _bot_ в файлах проекта, а
      затем `Mark directory as`->`Sources root`
    - при запуске через VS code нужно добавить папку `bot` в переменную среды `PYTHONPATH` через
      магию https://copyprogramming.com/howto/how-to-setup-pythonpath-env-in-vscode-properly
7. Поднимаем базу данных (`docker-compose up -d database`)
8. создаём alembic.ini по образу из alembic.ini.example и заполняем в нём `sqlalchemy.url` данными для подключения к БД
9. накатываем миграции командой ` python -m alembic upgrade head`
10. Запускаем `bot/main.py`
11. ???????
12. PROFIT!

### Структура проекта

- /bot - основная директория проекта
    - /commands (routes) - всё что взаимодействует с пользователем (но только с логикой обработки входных/выходных
      данных, без бизнес логики)
    - /core - константы, env конфиг, базовый функционал для переиспользования в internal
    - /repositories - вся логика доступа к данным
    - /services - вся бизнес логика проекта
    - /schemas - DTO классы и всё что нужно для выдачи данных из репозиториев
    - /models - ORM модели
    - /utils - директория с вспомогательным функционалом, который не относится напрямую к контексту решаемых задач
    - app.py - файл для настроек и инициализации бота
    - main.py - файл для запуска бота
- /tests - тесты

**P.S.:** бизнес логика - всё что касается выполнения наших задач (условно, все события из event storming)

### Основные абстракции проекта

Для разработки используется недо DDD подход, который позволяет более менее безопасно и безболезненно разрабатывать и
расширять ваше приложение.

**Repository**

Такой постфикс имеют все классы, отвечающие за доступ и изменение данных какой-то сущности (одной или нескольких таблиц
в бд). **За** их **пределами** **изменять** данные **нельзя**.

Например, `UserRepository` отвечает за создание/получение пользователей, обновление их информации. НО он не отвечает за
то, кто может это делать или как именно эти изменения будут вызваны.

Однако не стоит думать что это простая прокладка между ORM моделями и Service классами. Тут мы можем защитить наши
данные от неверных состояний. Например, запретить пользователю редактировать свой профиль пока он "неактивен".

**Service**

Он же услуга или если угодно обслуживатель сущности, отвечает за то, как и при каких условиях те или иные репозитории
будут изменяться. Service классы уже привязаны к бизнес процессам и описывают именно их. (например, у нас будет
AccountService для настроек пользователем своего профиля или же ParticipantService, для обработки логики участников).
Сервисы могут вызывать друг друга и любые Repository классы.

### А где DI

По хорошему, все Service, Repository и их зависимости вы не должны вручную создавать, как и передавать базовые для них
аргументы (ту же сессию к БД), но т.к. этот обучающий проект, здесь этот момент опущен ~~а ещё в питоне так никто и не
сделал человеческий DI модуль~~. 


